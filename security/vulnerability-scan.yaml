apiVersion: batch/v1
kind: CronJob
metadata:
  name: vulnerability-scan
  labels:
    app: payment-gateway
    component: security
spec:
  schedule: "0 4 * * *"  # Daily at 4 AM UTC
  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      backoffLimit: 2
      template:
        metadata:
          labels:
            app: payment-gateway
            component: security-scan
        spec:
          restartPolicy: OnFailure
          serviceAccountName: vulnerability-scanner
          securityContext:
            runAsNonRoot: true
            runAsUser: 10001
            fsGroup: 10001
          containers:
          - name: trivy-scanner
            image: aquasec/trivy:latest
            command:
            - /bin/sh
            - -c
            - |
              set -e
              
              echo "Starting vulnerability scan for Payment Gateway"
              
              # Scan the application image
              IMAGE_TAG=$(kubectl get deployment payment-gateway -o jsonpath='{.spec.template.spec.containers[0].image}')
              echo "Scanning image: $IMAGE_TAG"
              
              # Run comprehensive scan
              trivy image \
                --format json \
                --output /reports/vulnerability-report.json \
                --severity HIGH,CRITICAL \
                --ignore-unfixed \
                $IMAGE_TAG
              
              # Generate human-readable report
              trivy image \
                --format table \
                --output /reports/vulnerability-report.txt \
                --severity HIGH,CRITICAL \
                --ignore-unfixed \
                $IMAGE_TAG
              
              # Scan filesystem for secrets
              trivy fs \
                --format json \
                --output /reports/secrets-scan.json \
                --scanners secret \
                /app 2>/dev/null || echo "Filesystem scan completed"
              
              # Upload reports to S3 if configured
              if [ ! -z "${AWS_S3_BUCKET}" ]; then
                echo "Uploading reports to S3..."
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                aws s3 cp /reports/vulnerability-report.json s3://${AWS_S3_BUCKET}/security-reports/vulnerability-${TIMESTAMP}.json
                aws s3 cp /reports/vulnerability-report.txt s3://${AWS_S3_BUCKET}/security-reports/vulnerability-${TIMESTAMP}.txt
                aws s3 cp /reports/secrets-scan.json s3://${AWS_S3_BUCKET}/security-reports/secrets-${TIMESTAMP}.json
              fi
              
              # Check if critical vulnerabilities found
              CRITICAL_COUNT=$(cat /reports/vulnerability-report.json | jq '.Results[].Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' | wc -l)
              HIGH_COUNT=$(cat /reports/vulnerability-report.json | jq '.Results[].Vulnerabilities[]? | select(.Severity == "HIGH") | .VulnerabilityID' | wc -l)
              
              echo "Found $CRITICAL_COUNT critical and $HIGH_COUNT high severity vulnerabilities"
              
              # Send alert if critical vulnerabilities found
              if [ $CRITICAL_COUNT -gt 0 ]; then
                echo "ALERT: Critical vulnerabilities found!"
                # Here you could send alerts to Slack, email, etc.
                exit 1
              fi
              
              echo "Vulnerability scan completed successfully"
            env:
            - name: AWS_S3_BUCKET
              valueFrom:
                secretKeyRef:
                  name: vulnerability-scanner
                  key: s3-bucket
                  optional: true
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: vulnerability-scanner
                  key: aws-access-key-id
                  optional: true
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: vulnerability-scanner
                  key: aws-secret-access-key
                  optional: true
            volumeMounts:
            - name: reports
              mountPath: /reports
            - name: app-source
              mountPath: /app
              readOnly: true
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "512Mi"
                cpu: "500m"
          volumes:
          - name: reports
            emptyDir: {}
          - name: app-source
            projected:
              sources:
              - configMap:
                  name: app-source
                  optional: true
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vulnerability-scanner
  labels:
    app: payment-gateway
    component: security
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vulnerability-scanner
  labels:
    app: payment-gateway
    component: security
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vulnerability-scanner
  labels:
    app: payment-gateway
    component: security
subjects:
- kind: ServiceAccount
  name: vulnerability-scanner
roleRef:
  kind: Role
  name: vulnerability-scanner
  apiGroup: rbac.authorization.k8s.io
---
# Falco runtime security monitoring
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-rules
  labels:
    app: payment-gateway
    component: security
data:
  payment_gateway_rules.yaml: |
    - rule: Payment Gateway Unexpected Network Connection
      desc: Detect unexpected network connections from payment gateway pods
      condition: >
        (inbound_outbound) and
        k8s.ns.name = "payment-gateway" and
        k8s.deployment.name = "payment-gateway" and
        not fd.sport in (8080, 8081, 5432, 6379, 443, 80, 53, 9411)
      output: >
        Unexpected network connection from payment gateway
        (connection=%fd.name pod=%k8s.pod.name namespace=%k8s.ns.name
         sport=%fd.sport dport=%fd.dport)
      priority: WARNING
      tags: [network, payment-gateway]

    - rule: Payment Gateway Privilege Escalation
      desc: Detect privilege escalation attempts in payment gateway
      condition: >
        spawned_process and
        k8s.ns.name = "payment-gateway" and
        k8s.deployment.name = "payment-gateway" and
        (proc.name in (su, sudo, setuid, setgid) or
         proc.args contains "chmod +s")
      output: >
        Privilege escalation attempt in payment gateway
        (command=%proc.cmdline pod=%k8s.pod.name namespace=%k8s.ns.name)
      priority: HIGH
      tags: [privilege-escalation, payment-gateway]

    - rule: Payment Gateway File System Modification
      desc: Detect unauthorized file system modifications
      condition: >
        (modify or open_write) and
        k8s.ns.name = "payment-gateway" and
        k8s.deployment.name = "payment-gateway" and
        not fd.name startswith "/tmp" and
        not fd.name startswith "/app/logs" and
        not fd.name contains "spring.log"
      output: >
        Unauthorized file modification in payment gateway
        (file=%fd.name command=%proc.cmdline pod=%k8s.pod.name)
      priority: WARNING
      tags: [filesystem, payment-gateway]

    - rule: Payment Gateway Process Anomaly
      desc: Detect unexpected processes in payment gateway containers
      condition: >
        spawned_process and
        k8s.ns.name = "payment-gateway" and
        k8s.deployment.name = "payment-gateway" and
        not proc.name in (java, sh, bash, ps, grep, awk, sed, cut, sort, uniq)
      output: >
        Unexpected process in payment gateway container
        (command=%proc.cmdline pod=%k8s.pod.name namespace=%k8s.ns.name)
      priority: WARNING
      tags: [process, payment-gateway]
